        // Canvas rendern
        function renderCanvas() {

            // Verhindere mehrfaches gleichzeitiges Rendering
            if (window.renderingInProgress) {
                console.log('üõë Rendering bereits aktiv - √ºberspringe');
                return;
            }
            window.renderingInProgress = true;

            // TIMEOUT f√ºr Lock-Freigabe als Fallback (falls Code-Fehler auftritt)
            setTimeout(() => {
                if (window.renderingInProgress) {
                    console.warn('üîß Rendering-Lock nach 5s freigegeben (Fallback)');
                    window.renderingInProgress = false;
                }
            }, 5000);

            // Canvas komplett leeren vor Neuaufbau
            const canvas = document.getElementById('canvas');
            if (canvas) {
                canvas.innerHTML = '';
            }
            console.log('üîÑ renderCanvas gestartet');
            const placeholder = canvas.querySelector('.canvas-placeholder');

            // Alte Event Listener entfernen
            // removeModuleEventListeners(); // Auskommentiert - nicht mehr n√∂tig

            const moduleElements = canvas.querySelectorAll('.canvas-module');
            moduleElements.forEach(el => el.remove());
            // Canvas ohne Replacement verwenden - nur Module entfernen
            const freshCanvas = canvas;

            // Entferne alte Event Handler vom Canvas
            const oldCanvas = document.getElementById('canvas');
            if (oldCanvas && oldCanvas.hasAttribute('data-click-handler')) {
                oldCanvas.removeAttribute('data-click-handler');
                oldCanvas.removeEventListener('click', arguments.callee);
            }

            // Canvas-Click-Handler nur einmal hinzuf√ºgen (falls noch nicht vorhanden)
            if (!freshCanvas.hasAttribute('data-click-handler')) {
                freshCanvas.setAttribute('data-click-handler', 'true');
                freshCanvas.addEventListener('click', (e) => {
                    // Nur wenn Canvas selbst geklickt wurde (nicht ein Modul)
                    if (e.target === freshCanvas || e.target.classList.contains('canvas-placeholder')) {
                        console.log('üñ±Ô∏è Canvas geklickt - Deselektierung');
                        document.querySelectorAll('.canvas-module').forEach(el => {
                            el.classList.remove('selected');
                            el.style.zIndex = '';
                            el.style.position = '';
                            el.style.border = '';
                            el.style.boxShadow = '';
                        });
                        selectedModule = null;
                        window.selectedModule = null;
                        renderPropertyPanel();
                        showNotification('‚úÖ Auswahl aufgehoben');
                    }
                });
            }

            if (modules.length === 0) {
                if (placeholder) placeholder.style.display = 'block';
                return;
            }

            if (placeholder) placeholder.style.display = 'none';

            // üîç DEBUG: Module-Array vor Rendering pr√ºfen
            console.log('üìä Module-Array vor Rendering:');
            modules.forEach((mod, idx) => {
                console.log(`  ${idx}: ${mod.id} -> ${mod.name}`);
            });

            // üîß REPARATUR: Doppelte IDs vor Rendering pr√ºfen und korrigieren
            const idCounts = {};
            modules.forEach(module => {
                idCounts[module.id] = (idCounts[module.id] || 0) + 1;
            });

            const duplicateIds = Object.keys(idCounts).filter(id => idCounts[id] > 1);
            if (duplicateIds.length > 0) {
                console.warn('‚ö†Ô∏è Doppelte Modul-IDs gefunden:', duplicateIds);
                
                // IDs automatisch korrigieren
                duplicateIds.forEach(duplicateId => {
                    const duplicateModules = modules.filter(m => m.id === duplicateId);
                    for (let i = 1; i < duplicateModules.length; i++) {
                        duplicateModules[i].id = `module_${++moduleCounter}_fixed`;
                        console.log('üîß ID korrigiert:', duplicateId, '‚Üí', duplicateModules[i].id);
                    }
                });
            }

            modules.forEach((module, index) => {
                console.log(`üèóÔ∏è Erstelle DOM f√ºr Modul ${index}:`, module.id, '‚Üí', module.name);

                const moduleDiv = document.createElement('div');
                moduleDiv.className = 'canvas-module';
                moduleDiv.dataset.moduleId = module.id;

                // üîß REPARATUR: Sauberes HTML OHNE onclick-Attribute
                moduleDiv.innerHTML = `
                    <div class="module-controls">
                        <button class="control-btn btn-edit" data-action="select" data-module-id="${module.id}" title="Bearbeiten">‚úèÔ∏è</button>
                        <button class="control-btn btn-edit" data-action="editInfo" data-module-id="${module.id}" title="Modul-Info bearbeiten">‚ÑπÔ∏è</button>
                        <button class="control-btn btn-copy" data-action="copy" data-module-id="${module.id}" title="Code kopieren">üìã</button>
                        <button class="control-btn btn-copy" data-action="export" data-module-id="${module.id}" title="Modul exportieren">üì§</button>
                        <button class="control-btn btn-move" data-action="moveUp" data-module-id="${module.id}" title="Nach oben">‚Üë</button>
                        <button class="control-btn btn-move" data-action="moveDown" data-module-id="${module.id}" title="Nach unten">‚Üì</button>
                        <button class="control-btn btn-delete" data-action="delete" data-module-id="${module.id}" title="L√∂schen">üóëÔ∏è</button>
                    </div>
                    <div style="padding: 0.5rem; background: rgba(6,58,168,0.02); border-radius: 4px; margin-bottom: 0.5rem; font-size: 0.8rem; color: #6c757d; border: 1px solid rgba(6,58,168,0.1);">
                        üìÑ ${module.name} <span style="opacity: 0.7;">| ${module.category || 'Uncategorized'}</span>
                        <span style="background: #28a745; color: white; padding: 0.1rem 0.4rem; border-radius: 10px; font-size: 0.7rem; margin-left: 0.5rem;">LIVE</span>
                    </div>
                    <div class="module-content">${processModuleHTML(module)}</div>
                `;

                // üîß REPARATUR: Event-Delegation mit Closure-Fix
                (function (moduleId, moduleName) {
                    moduleDiv.addEventListener('click', function (e) {
                        e.stopPropagation(); // Verhindere Canvas-Click

                        if (e.target.classList.contains('control-btn')) {
                            // Button-Clicks behandeln
                            const action = e.target.dataset.action;
                            const targetModuleId = e.target.dataset.moduleId;

                            console.log('üîò Button-Click:', action, 'f√ºr Modul:', targetModuleId, '(' + moduleName + ')');

                            switch (action) {
                                case 'select':
                                    selectModule(targetModuleId);
                                    break;
                                case 'editInfo':
                                    if (typeof editModuleInfo === 'function') editModuleInfo(targetModuleId);
                                    break;
                                case 'copy':
                                    if (typeof copyModuleCode === 'function') copyModuleCode(targetModuleId);
                                    break;
                                case 'export':
                                    if (typeof exportSingleModule === 'function') exportSingleModule(targetModuleId);
                                    break;
                                case 'moveUp':
                                    if (typeof moveModule === 'function') moveModule(targetModuleId, -1);
                                    break;
                                case 'moveDown':
                                    if (typeof moveModule === 'function') moveModule(targetModuleId, 1);
                                    break;
                                case 'delete':
                                    if (typeof deleteIndividualModule === 'function') deleteIndividualModule(targetModuleId);
                                    break;
                                default:
                                    console.warn('‚ùì Unbekannte Aktion:', action);
                            }
                        } else {
                            // Klick auf Modul-Content (nicht auf Button)
                            console.log('üñ±Ô∏è Modul-Content-Click:', moduleId, '(' + moduleName + ')');
                            selectModule(moduleId);
                        }
                    });
                })(module.id, module.name);

                // üîç DEBUG: Verifiziere DOM-Element
                console.log('‚úÖ DOM-Element erstellt f√ºr:', module.id, 'mit data-module-id:', moduleDiv.dataset.moduleId);

                // DUPLIKAT-PR√ÑVENTION: Pr√ºfe ob Element bereits existiert
                const existingElement = freshCanvas.querySelector(`[data-module-id="${module.id}"]`);
                if (existingElement) {
                    console.warn('‚ö†Ô∏è Verhindere Duplikat f√ºr:', module.id);
                    existingElement.remove();
                }

                freshCanvas.appendChild(moduleDiv);
            });

            // üîç FINAL DEBUG: Pr√ºfe DOM-Struktur nach Rendering
            console.log('üìä DOM-Struktur nach Rendering:');
            const renderedModules = freshCanvas.querySelectorAll('.canvas-module');
            renderedModules.forEach((el, idx) => {
                console.log(`  DOM ${idx}: data-module-id="${el.dataset.moduleId}"`);
            });

            // Testimonials Carousels nach dem Rendering initialisieren
            setTimeout(() => {
                if (typeof initializeTestimonialsCarousels === 'function') {
                    initializeTestimonialsCarousels();
                }
            }, 100);

            console.log('‚úÖ renderCanvas abgeschlossen - ', modules.length, 'Module gerendert');

            // Guide Flow Interaktivit√§t nach dem Rendering initialisieren
            setTimeout(() => {
                if (typeof enhanceGuideFlowInteractivity === 'function') {
                    enhanceGuideFlowInteractivity();
                }
            }, 200);

            // ===== FAQ-INTERAKTIVIT√ÑT REAKTIVIEREN =====
            setTimeout(() => {
                console.log('üîÑ Reaktiviere FAQ-Interaktivit√§t nach Canvas-Rendering...');
                activateModuleInteractivity();
            }, 150);

            // Zus√§tzlicher Fallback f√ºr FAQ-Interaktivit√§t
            setTimeout(() => {
                console.log('üîÑ FAQ-Interaktivit√§t Fallback...');
                activateModuleInteractivity();
            }, 400);

            // Event Handler f√ºr dynamische Buttons neu binden
            setTimeout(() => {
                bindDynamicButtonHandlers();
                
                // Rendering-Lock freigeben
                window.renderingInProgress = false;
                console.log('üéØ Event Handler gebunden - Rendering vollst√§ndig abgeschlossen');
            }, 100);

            // Event Handler f√ºr dynamische Buttons neu binden
            setTimeout(() => {
                bindDynamicButtonHandlers();
                
                // Rendering-Lock freigeben
                window.renderingInProgress = false;
                console.log('üéØ Event Handler gebunden - Rendering vollst√§ndig abgeschlossen');
            }, 100);
        }

        // Modul zum Canvas hinzuf√ºgen
        function addModuleToCanvas(templateId) {
            const template = MODULE_TEMPLATES.find(t => t && t.id === templateId);
            if (!template) {
                console.error('Template nicht gefunden:', templateId);
                showNotification('‚ùå Template nicht gefunden: ' + templateId);
                return;
            }

            // üîß REPARATUR: Eindeutige ID-Generierung mit Kollisionspr√ºfung
            function generateUniqueModuleId() {
                let newId;
                let attempts = 0;
                do {
                    newId = `module_${++moduleCounter}`;
                    attempts++;
                    // Fallback nach 1000 Versuchen
                    if (attempts > 1000) {
                        newId = `module_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                        break;
                    }
                } while (modules.some(m => m.id === newId) || document.querySelector(`[data-module-id="${newId}"]`));
                return newId;
            }

            const module = {
                id: generateUniqueModuleId(),
                templateId: templateId,
                html: template.html,
                properties: { ...template.properties },
                name: template.name,
                category: template.category,
                description: template.description
            };

            modules.push(module);
            // üîß REPARATUR: Synchronisation sicherstellen
            window.modules = modules;
            renderCanvas();
            selectModule(module.id);

            const placeholder = document.querySelector('.canvas-placeholder');
            if (placeholder) placeholder.style.display = 'none';

            showNotification('‚úÖ ' + template.name + ' hinzugef√ºgt');
        }

        // Modul ausw√§hlen
        function selectModule(moduleId) {
            console.log('üéØ selectModule aufgerufen:', moduleId);

            // üîß REPARATUR: Erlaube Auswahl aller Module
            console.log('üîÑ Wechsle von', selectedModule?.id, 'zu', moduleId);

            // NUR Canvas-Module deselektieren - NICHT die Control-Buttons!
            document.querySelectorAll('.canvas-module').forEach(el => {
                el.classList.remove('selected', 'active');
                el.style.zIndex = '';
                el.style.position = '';
                el.style.border = '';
                el.style.boxShadow = '';
                el.style.background = '';
            });

            // NULL-CHECK f√ºr moduleId
            if (!moduleId) {
                console.log('üìù Keine Modul-ID - deselektiere alles');
                selectedModule = null;
                renderPropertyPanel();
                return;
            }

            // Finde das neue Modul
            const targetModule = modules.find(m => m.id === moduleId);
            if (!targetModule) {
                console.error('‚ùå Modul nicht gefunden:', moduleId);
                selectedModule = null;
                renderPropertyPanel();
                return;
            }

            // üîß REPARATUR: Sanfte DOM-Element-Suche (nicht l√∂schen!)
            let moduleElements = document.querySelectorAll(`[data-module-id="${moduleId}"]`);
            if (moduleElements.length === 0) {
                // Warte kurz und versuche erneut (manchmal ist Rendering noch nicht fertig)
                setTimeout(() => {
                    moduleElements = document.querySelectorAll(`[data-module-id="${moduleId}"]`);
                    if (moduleElements.length > 0) {
                        console.log('‚úÖ DOM-Element gefunden nach Verz√∂gerung:', moduleId);
                        markSelectedModule(moduleElements[0], moduleId);
                    } else {
                        console.warn('‚ö†Ô∏è DOM-Element nicht gefunden auch nach Verz√∂gerung:', moduleId);
                    }
                }, 50);
                return; // Fr√ºh return wenn Element nicht gefunden
            }

            // Entferne nur echte Duplikate (nicht das erste Element!)
            if (moduleElements.length > 1) {
                console.warn('‚ö†Ô∏è Mehrere DOM-Elemente gefunden:', moduleId, moduleElements.length);
                
                // SOFORTIGE Bereinigung aller Duplikate
                const canvas = document.getElementById('canvas');
                if (canvas) {
                    const allDuplicates = canvas.querySelectorAll(`[data-module-id="${moduleId}"]`);
                    for (let i = 1; i < allDuplicates.length; i++) {
                        allDuplicates[i].remove();
                        console.log('üóëÔ∏è Duplikat entfernt');
                    }
                }
                
                // Erneut scannen nach Bereinigung
                moduleElements = document.querySelectorAll(`[data-module-id="${moduleId}"]`);
                
                // Wenn immer noch Duplikate vorhanden, Canvas komplett neu rendern
                if (moduleElements.length > 1) {
                    console.warn('üîÑ Erzwinge Canvas-Neu-Rendering wegen persistenter Duplikate');
                    renderCanvas();
                    return; // Fr√ºher Ausstieg, selectModule wird nach renderCanvas automatisch aufgerufen
                }
            }

            // Warte kurz und pr√ºfe erneut
            setTimeout(() => {
                const moduleElements = document.querySelectorAll(`[data-module-id="${moduleId}"]`);
                if (moduleElements.length > 1) {
                    console.warn('‚ö†Ô∏è Mehrere DOM-Elemente nach Bereinigung gefunden:', moduleId);
                    // Entferne Duplikate (behalte nur das erste)
                    for (let i = 1; i < moduleElements.length; i++) {
                        moduleElements[i].remove();
                        console.log('üóëÔ∏è Nachtr√§glich entfernt');
                    }
                }
            }, 10);

            // SCHUTZ: Pr√ºfe ob Modul tats√§chlich existiert
            const moduleExists = modules.find(m => m.id === moduleId);
            if (!moduleExists) {
                console.error('‚ùå Modul existiert nicht im modules-Array:', moduleId);
                selectedModule = null;
                renderPropertyPanel();
                return;
            }

            // DOM-Element finden und markieren
            const moduleEl = document.querySelector(`[data-module-id="${moduleId}"]`);
            if (moduleEl) {
                moduleEl.classList.add('selected');
                moduleEl.style.zIndex = '5';
                moduleEl.style.position = 'relative';
                moduleEl.style.border = '2px solid #063AA8';
                moduleEl.style.boxShadow = '0 4px 12px rgba(6,58,168,0.2)';
                console.log('‚úÖ DOM-Element markiert:', moduleId);
            } else {
                console.warn('‚ö†Ô∏è DOM-Element nicht gefunden f√ºr:', moduleId);
            }

            // Globale Variable setzen
            selectedModule = targetModule;
            window.selectedModule = targetModule;

            console.log('‚úÖ Modul ausgew√§hlt:', selectedModule.name);

            // Property Panel aktualisieren
            renderPropertyPanel();
            updateExportButtons();
            // Enhanced Guide-Flow Editor mit Verz√∂gerung
            setTimeout(() => {
                setupGuideFlowPropertyPanel(moduleId);
            }, 200);
        }


        function validateCanvasState() {
            const canvas = document.getElementById('canvas');
            if (!canvas || !window.modules) return;
            
            const domCount = canvas.querySelectorAll('.canvas-module').length;
            const moduleCount = window.modules.length;
            
            if (domCount !== moduleCount) {
                console.warn(`‚ö†Ô∏è Canvas-Mismatch: ${domCount} DOM vs ${moduleCount} Module`);
            }
        }        

        window.copyModuleCode = function (moduleId) {
            const module = modules.find(m => m.id === moduleId);
            if (!module) return;

            navigator.clipboard.writeText(processModuleHTML(module)).then(() => {
                showNotification('üìã ' + module.name + ' Code kopiert');
            });
        };

        window.moveModule = function (moduleId, direction) {
            const index = modules.findIndex(m => m.id === moduleId);
            if (index === -1) return;

            const newIndex = index + direction;
            if (newIndex < 0 || newIndex >= modules.length) return;

            [modules[index], modules[newIndex]] = [modules[newIndex], modules[index]];
            renderCanvas();
            selectModule(moduleId);
        };

        window.deleteModule = function (moduleId) {
            if (confirm('Modul wirklich l√∂schen?')) {
                const module = modules.find(m => m.id === moduleId);
                if (!module) return;

                const moduleName = module.name;
                modules = modules.filter(m => m.id !== moduleId);
                renderCanvas();

                // Wenn das gel√∂schte Modul ausgew√§hlt war, Property Panel zur√ºcksetzen
                if (selectedModule && selectedModule.id === moduleId) {
                    selectedModule = null;
                    renderPropertyPanel();
                }

                // Placeholder anzeigen falls keine Module mehr da sind
                if (modules.length === 0) {
                    const placeholder = document.querySelector('.canvas-placeholder');
                    if (placeholder) placeholder.style.display = 'block';
                }

                showNotification(`üóëÔ∏è Modul "${moduleName}" gel√∂scht`);
            }
        };

        window.duplicateModule = function (moduleId) {
            const module = modules.find(m => m.id === moduleId);
            if (!module) return;

            // üîß REPARATUR: Eindeutige ID auch beim Duplizieren
            function generateUniqueModuleId() {
                let newId;
                let attempts = 0;
                do {
                    newId = `module_${++moduleCounter}`;
                    attempts++;
                    if (attempts > 1000) {
                        newId = `module_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                        break;
                    }
                } while (modules.some(m => m.id === newId));
                return newId;
            }

            const duplicate = {
                id: generateUniqueModuleId(),
                templateId: module.templateId,
                html: module.html,
                properties: { ...module.properties },
                name: module.name + ' (Kopie)'
            };

            const index = modules.findIndex(m => m.id === moduleId);
            modules.splice(index + 1, 0, duplicate);
            renderCanvas();
            showNotification('üìã Modul dupliziert');
        };
